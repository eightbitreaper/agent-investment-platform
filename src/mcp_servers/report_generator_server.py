"""
Report Generator MCP Server for the Agent Investment Platform.

This server provides automated investment report generation and publishing
capabilities including template management, chart generation, and GitHub publishing.
"""

import asyncio
import json
import os
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from pathlib import Path
import base64
from jinja2 import Template, Environment, FileSystemLoader
import markdown

from .base import MCPServerBase, MCPTool, MCPError, MCPValidationError, create_tool_schema


@dataclass
class ReportTemplate:
    """Represents a report template."""
    name: str
    description: str
    template_path: str
    output_format: str  # "markdown", "html", "pdf"
    required_data: List[str]

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class GeneratedReport:
    """Represents a generated report."""
    title: str
    content: str
    format: str
    template_name: str
    generated_at: datetime
    file_path: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None

    def to_dict(self) -> Dict[str, Any]:
        result = asdict(self)
        result["generated_at"] = result["generated_at"].isoformat()
        return result


class TemplateManager:
    """Manages report templates."""

    def __init__(self, templates_dir: str = "templates/reports"):
        self.templates_dir = Path(templates_dir)
        self.templates_dir.mkdir(parents=True, exist_ok=True)

        # Initialize Jinja2 environment
        self.env = Environment(
            loader=FileSystemLoader(str(self.templates_dir)),
            autoescape=True
        )

        # Create default templates if they don't exist
        self._create_default_templates()

    def _create_default_templates(self):
        """Create default report templates."""

        # Stock Analysis Report Template
        stock_analysis_template = """# {{title}}

## Executive Summary

**Symbol:** {{data.symbol}}
**Analysis Date:** {{data.analysis_date}}
**Recommendation:** {{data.recommendation | upper}}
**Target Price:** ${{data.target_price}}
**Current Price:** ${{data.current_price}}

## Technical Analysis

{% if data.technical_analysis %}
### Key Indicators

| Indicator | Value | Signal |
|-----------|-------|--------|
{% for indicator in data.technical_analysis.indicators %}
| {{indicator.name}} | {{indicator.value}} | {{indicator.signal}} |
{% endfor %}

### Chart Analysis
{{data.technical_analysis.summary}}
{% endif %}

## Fundamental Analysis

{% if data.fundamental_analysis %}
### Financial Metrics

| Metric | Value | Industry Avg |
|--------|-------|--------------|
| P/E Ratio | {{data.fundamental_analysis.pe_ratio}} | {{data.fundamental_analysis.industry_pe}} |
| Debt/Equity | {{data.fundamental_analysis.debt_equity}} | {{data.fundamental_analysis.industry_debt_equity}} |
| ROE | {{data.fundamental_analysis.roe}}% | {{data.fundamental_analysis.industry_roe}}% |

### Valuation
{{data.fundamental_analysis.valuation_summary}}
{% endif %}

## Risk Assessment

{% if data.risk_assessment %}
- **Volatility:** {{data.risk_assessment.volatility}}%
- **Beta:** {{data.risk_assessment.beta}}
- **VaR (95%):** {{data.risk_assessment.var_95}}%
- **Risk Score:** {{data.risk_assessment.risk_score}}/100

{{data.risk_assessment.summary}}
{% endif %}

## Investment Thesis

{{data.investment_thesis}}

## Risks and Considerations

{% for risk in data.risks %}
- {{risk}}
{% endfor %}

## Conclusion

{{data.conclusion}}

---
*Report generated by Agent Investment Platform on {{data.analysis_date}}*
"""

        stock_template_path = self.templates_dir / "stock_analysis.md"
        if not stock_template_path.exists():
            with open(stock_template_path, 'w', encoding='utf-8') as f:
                f.write(stock_analysis_template)

        # Portfolio Analysis Report Template
        portfolio_template = """# {{title}}

## Portfolio Overview

**Analysis Date:** {{data.analysis_date}}
**Total Value:** ${{data.total_value}}
**Period:** {{data.period}}

## Asset Allocation

| Asset | Symbol | Weight | Value | Return |
|-------|--------|--------|-------|--------|
{% for asset in data.assets %}
| {{asset.name}} | {{asset.symbol}} | {{asset.weight}}% | ${{asset.value}} | {{asset.return}}% |
{% endfor %}

## Performance Summary

- **Total Return:** {{data.performance.total_return}}%
- **Annualized Return:** {{data.performance.annualized_return}}%
- **Volatility:** {{data.performance.volatility}}%
- **Sharpe Ratio:** {{data.performance.sharpe_ratio}}
- **Max Drawdown:** {{data.performance.max_drawdown}}%

## Risk Metrics

| Metric | Value | Benchmark |
|--------|-------|-----------|
| Beta | {{data.risk.beta}} | 1.0 |
| Volatility | {{data.risk.volatility}}% | {{data.risk.benchmark_volatility}}% |
| VaR (95%) | {{data.risk.var_95}}% | {{data.risk.benchmark_var}}% |

## Recommendations

{% for recommendation in data.recommendations %}
### {{recommendation.title}}
{{recommendation.description}}

**Action:** {{recommendation.action}}
**Priority:** {{recommendation.priority}}
{% endfor %}

## Market Commentary

{{data.market_commentary}}

---
*Report generated by Agent Investment Platform on {{data.analysis_date}}*
"""

        portfolio_template_path = self.templates_dir / "portfolio_analysis.md"
        if not portfolio_template_path.exists():
            with open(portfolio_template_path, 'w', encoding='utf-8') as f:
                f.write(portfolio_template)

        # Daily Market Summary Template
        market_summary_template = """# Daily Market Summary - {{data.date}}

## Market Overview

**Date:** {{data.date}}
**Market Status:** {{data.market_status}}

### Major Indices

| Index | Value | Change | Change % |
|-------|-------|--------|----------|
{% for index in data.indices %}
| {{index.name}} | {{index.value}} | {{index.change}} | {{index.change_percent}}% |
{% endfor %}

## Top Movers

### Top Gainers
{% for gainer in data.top_gainers %}
- **{{gainer.symbol}}**: {{gainer.change_percent}}% ({{gainer.price}})
{% endfor %}

### Top Losers
{% for loser in data.top_losers %}
- **{{loser.symbol}}**: {{loser.change_percent}}% ({{loser.price}})
{% endfor %}

## Sector Performance

| Sector | Performance |
|--------|-------------|
{% for sector in data.sectors %}
| {{sector.name}} | {{sector.performance}}% |
{% endfor %}

## News Highlights

{% for news in data.news %}
### {{news.title}}
{{news.summary}}
*Source: {{news.source}}*

{% endfor %}

## Market Sentiment

**Overall Sentiment:** {{data.sentiment.overall}}
**Fear & Greed Index:** {{data.sentiment.fear_greed}}

{{data.sentiment.analysis}}

---
*Report generated by Agent Investment Platform on {{data.date}}*
"""

        market_template_path = self.templates_dir / "market_summary.md"
        if not market_template_path.exists():
            with open(market_template_path, 'w', encoding='utf-8') as f:
                f.write(market_summary_template)

    def get_template(self, template_name: str) -> Template:
        """Get a template by name."""
        try:
            return self.env.get_template(f"{template_name}.md")
        except Exception as e:
            raise MCPError(-32602, f"Template not found: {template_name}")

    def list_templates(self) -> List[ReportTemplate]:
        """List available templates."""
        templates = []

        for template_file in self.templates_dir.glob("*.md"):
            template_name = template_file.stem
            templates.append(ReportTemplate(
                name=template_name,
                description=f"Template for {template_name.replace('_', ' ').title()}",
                template_path=str(template_file),
                output_format="markdown",
                required_data=["title", "data"]
            ))

        return templates

    def render_template(self, template_name: str, data: Dict[str, Any]) -> str:
        """Render a template with data."""
        template = self.get_template(template_name)
        return template.render(**data)


class GitHubPublisher:
    """Publishes reports to GitHub repository."""

    def __init__(self, github_token: Optional[str] = None, repo: Optional[str] = None):
        self.github_token = github_token
        self.repo = repo

        if not self.github_token:
            logging.warning("GitHub token not provided - publishing will be disabled")

        if not self.repo:
            logging.warning("GitHub repository not provided - publishing will be disabled")

    async def publish_report(self, report: GeneratedReport, path: str) -> Dict[str, Any]:
        """Publish a report to GitHub repository."""
        if not self.github_token or not self.repo:
            raise MCPError(-32503, "GitHub credentials not configured")

        # For now, return mock response - would implement actual GitHub API calls
        return {
            "published": True,
            "url": f"https://github.com/{self.repo}/blob/main/{path}",
            "sha": "mock_sha_hash",
            "message": f"Published report: {report.title}"
        }


class ChartGenerator:
    """Generates charts for reports."""

    def __init__(self):
        pass

    async def generate_price_chart(self, symbol: str, prices: List[Dict[str, Any]],
                                 width: int = 800, height: int = 400) -> str:
        """Generate a price chart."""
        # Mock implementation - would use matplotlib or similar
        chart_data = {
            "type": "line",
            "symbol": symbol,
            "data_points": len(prices),
            "width": width,
            "height": height,
            "generated": datetime.now().isoformat()
        }

        # Return base64 encoded placeholder
        return base64.b64encode(json.dumps(chart_data).encode()).decode()

    async def generate_portfolio_allocation_chart(self, allocations: Dict[str, float]) -> str:
        """Generate a portfolio allocation pie chart."""
        # Mock implementation
        chart_data = {
            "type": "pie",
            "allocations": allocations,
            "generated": datetime.now().isoformat()
        }

        return base64.b64encode(json.dumps(chart_data).encode()).decode()


class ReportGeneratorServer(MCPServerBase):
    """
    MCP Server for report generation operations.

    Provides tools for:
    - Generating investment reports from templates
    - Managing report templates
    - Publishing reports to GitHub
    - Chart generation for reports
    """

    def __init__(self):
        super().__init__(
            name="report-generator-server",
            version="1.0.0",
            description="Automated investment report generation and publishing"
        )

        # Initialize components
        self.reports_dir = Path(os.environ.get("REPORTS_DIRECTORY", "reports"))
        self.reports_dir.mkdir(parents=True, exist_ok=True)

        self.template_manager = TemplateManager()
        self.github_publisher = GitHubPublisher(
            github_token=os.environ.get("GITHUB_TOKEN"),
            repo=os.environ.get("GITHUB_REPO")
        )
        self.chart_generator = ChartGenerator()

    def _register_capabilities(self):
        """Register report generation tools."""

        # Generate report tool
        generate_tool = MCPTool(
            name="generate_report",
            description="Generate an investment report from template and data",
            inputSchema=create_tool_schema(
                name="generate_report",
                description="Generate investment report",
                properties={
                    "template_name": {
                        "type": "string",
                        "description": "Name of the report template to use",
                        "enum": ["stock_analysis", "portfolio_analysis", "market_summary"]
                    },
                    "title": {
                        "type": "string",
                        "description": "Report title"
                    },
                    "data": {
                        "type": "object",
                        "description": "Data to populate the report template",
                        "additionalProperties": True
                    },
                    "output_format": {
                        "type": "string",
                        "description": "Output format for the report",
                        "enum": ["markdown", "html"],
                        "default": "markdown"
                    },
                    "save_to_file": {
                        "type": "boolean",
                        "description": "Whether to save the report to a file",
                        "default": True
                    }
                },
                required=["template_name", "title", "data"]
            )
        )
        self.register_tool(generate_tool, self._handle_generate_report)

        # List templates tool
        templates_tool = MCPTool(
            name="list_templates",
            description="List available report templates",
            inputSchema=create_tool_schema(
                name="list_templates",
                description="List report templates",
                properties={}
            )
        )
        self.register_tool(templates_tool, self._handle_list_templates)

        # Publish report tool
        publish_tool = MCPTool(
            name="publish_report",
            description="Publish a generated report to GitHub",
            inputSchema=create_tool_schema(
                name="publish_report",
                description="Publish report to GitHub",
                properties={
                    "report_path": {
                        "type": "string",
                        "description": "Path to the report file to publish"
                    },
                    "github_path": {
                        "type": "string",
                        "description": "Target path in GitHub repository",
                        "default": "reports/"
                    },
                    "commit_message": {
                        "type": "string",
                        "description": "Commit message for the publication"
                    }
                },
                required=["report_path"]
            )
        )
        self.register_tool(publish_tool, self._handle_publish_report)

        # Generate chart tool
        chart_tool = MCPTool(
            name="generate_chart",
            description="Generate a chart for use in reports",
            inputSchema=create_tool_schema(
                name="generate_chart",
                description="Generate chart",
                properties={
                    "chart_type": {
                        "type": "string",
                        "description": "Type of chart to generate",
                        "enum": ["price_chart", "portfolio_allocation", "performance"]
                    },
                    "data": {
                        "type": "object",
                        "description": "Data for chart generation",
                        "additionalProperties": True
                    },
                    "options": {
                        "type": "object",
                        "description": "Chart options (width, height, etc.)",
                        "properties": {
                            "width": {"type": "integer", "default": 800},
                            "height": {"type": "integer", "default": 400}
                        }
                    }
                },
                required=["chart_type", "data"]
            )
        )
        self.register_tool(chart_tool, self._handle_generate_chart)

        # Batch report generation tool
        batch_tool = MCPTool(
            name="generate_batch_reports",
            description="Generate multiple reports in batch",
            inputSchema=create_tool_schema(
                name="generate_batch_reports",
                description="Generate multiple reports",
                properties={
                    "reports": {
                        "type": "array",
                        "description": "Array of report specifications",
                        "items": {
                            "type": "object",
                            "properties": {
                                "template_name": {"type": "string"},
                                "title": {"type": "string"},
                                "data": {"type": "object"},
                                "filename": {"type": "string"}
                            },
                            "required": ["template_name", "title", "data"]
                        },
                        "maxItems": 10
                    },
                    "output_format": {
                        "type": "string",
                        "enum": ["markdown", "html"],
                        "default": "markdown"
                    }
                },
                required=["reports"]
            )
        )
        self.register_tool(batch_tool, self._handle_generate_batch_reports)

    async def _handle_generate_report(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle report generation request."""
        template_name = params.get("template_name")
        title = params.get("title")
        data = params.get("data", {})
        output_format = params.get("output_format", "markdown")
        save_to_file = params.get("save_to_file", True)

        if not template_name or not title:
            raise MCPValidationError("Template name and title are required")

        try:
            # Prepare template data
            template_data = {
                "title": title,
                "data": data
            }

            # Generate report content
            content = self.template_manager.render_template(template_name, template_data)

            # Convert to HTML if requested
            if output_format == "html":
                content = markdown.markdown(content, extensions=['tables'])

            # Create report object
            report = GeneratedReport(
                title=title,
                content=content,
                format=output_format,
                template_name=template_name,
                generated_at=datetime.now(),
                metadata={"data_keys": list(data.keys())}
            )

            # Save to file if requested
            if save_to_file:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"{template_name}_{timestamp}.{output_format}"
                file_path = self.reports_dir / filename

                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)

                report.file_path = str(file_path)
                self.logger.info(f"Report saved to: {file_path}")

            return {
                "success": True,
                "data": report.to_dict()
            }

        except Exception as e:
            self.logger.error(f"Error generating report: {e}")
            raise MCPError(-32603, f"Report generation failed: {str(e)}")

    async def _handle_list_templates(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle list templates request."""
        try:
            templates = self.template_manager.list_templates()

            return {
                "success": True,
                "data": {
                    "templates": [template.to_dict() for template in templates],
                    "count": len(templates)
                }
            }

        except Exception as e:
            self.logger.error(f"Error listing templates: {e}")
            raise MCPError(-32603, f"Failed to list templates: {str(e)}")

    async def _handle_publish_report(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle report publishing request."""
        report_path = params.get("report_path")
        github_path = params.get("github_path", "reports/")
        commit_message = params.get("commit_message", "Publish investment report")

        if not report_path:
            raise MCPValidationError("Report path is required")

        report_file = Path(report_path)
        if not report_file.exists():
            raise MCPValidationError(f"Report file not found: {report_path}")

        try:
            # Read report content
            with open(report_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # Create a mock report object for publishing
            report = GeneratedReport(
                title=report_file.stem,
                content=content,
                format=report_file.suffix[1:],  # Remove the dot
                template_name="unknown",
                generated_at=datetime.now(),
                file_path=str(report_file)
            )

            # Publish to GitHub
            target_path = f"{github_path.rstrip('/')}/{report_file.name}"
            result = await self.github_publisher.publish_report(report, target_path)

            return {
                "success": True,
                "data": result
            }

        except Exception as e:
            self.logger.error(f"Error publishing report: {e}")
            raise MCPError(-32603, f"Report publishing failed: {str(e)}")

    async def _handle_generate_chart(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle chart generation request."""
        chart_type = params.get("chart_type")
        data = params.get("data", {})
        options = params.get("options", {})

        if not chart_type:
            raise MCPValidationError("Chart type is required")

        try:
            if chart_type == "price_chart":
                symbol = data.get("symbol", "UNKNOWN")
                prices = data.get("prices", [])
                chart_data = await self.chart_generator.generate_price_chart(
                    symbol, prices,
                    options.get("width", 800),
                    options.get("height", 400)
                )

            elif chart_type == "portfolio_allocation":
                allocations = data.get("allocations", {})
                chart_data = await self.chart_generator.generate_portfolio_allocation_chart(allocations)

            else:
                raise MCPValidationError(f"Unsupported chart type: {chart_type}")

            return {
                "success": True,
                "data": {
                    "chart_type": chart_type,
                    "chart_data": chart_data,
                    "format": "base64_encoded",
                    "generated_at": datetime.now().isoformat()
                }
            }

        except Exception as e:
            self.logger.error(f"Error generating chart: {e}")
            raise MCPError(-32603, f"Chart generation failed: {str(e)}")

    async def _handle_generate_batch_reports(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Handle batch report generation request."""
        reports_specs = params.get("reports", [])
        output_format = params.get("output_format", "markdown")

        if not reports_specs:
            raise MCPValidationError("Reports array is required")

        if len(reports_specs) > 10:
            raise MCPValidationError("Maximum 10 reports allowed per batch")

        results = []
        errors = []

        for i, spec in enumerate(reports_specs):
            try:
                # Generate individual report
                result = await self._handle_generate_report({
                    "template_name": spec.get("template_name"),
                    "title": spec.get("title"),
                    "data": spec.get("data", {}),
                    "output_format": output_format,
                    "save_to_file": True
                })

                results.append({
                    "index": i,
                    "title": spec.get("title"),
                    "result": result["data"]
                })

            except Exception as e:
                errors.append({
                    "index": i,
                    "title": spec.get("title", "Unknown"),
                    "error": str(e)
                })

        return {
            "success": True,
            "data": {
                "generated_reports": results,
                "errors": errors,
                "summary": {
                    "total_requested": len(reports_specs),
                    "successful": len(results),
                    "failed": len(errors)
                }
            }
        }

    async def health_check(self) -> Dict[str, Any]:
        """Perform health check."""
        status = {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "version": self.version,
            "reports_directory": str(self.reports_dir),
            "templates_available": len(self.template_manager.list_templates()),
            "github_configured": bool(self.github_publisher.github_token and self.github_publisher.repo)
        }

        # Check reports directory
        if not self.reports_dir.exists():
            status["reports_directory_status"] = "missing"
            status["status"] = "degraded"
        else:
            status["reports_directory_status"] = "available"

        return status


async def main():
    """Main entry point for the Report Generator Server."""
    server = ReportGeneratorServer()
    await server.run_stdio()


if __name__ == "__main__":
    asyncio.run(main())
